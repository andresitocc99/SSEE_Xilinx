#include "platform.h"
#include "xparameters.h"

#include "lib_hyperspectral_hw.h"
#include "xscugic.h"
#include "xaxidma.h"
#include "xhyperspectral_hw_wrapped.h"
#include "xil_printf.h"

#define XPAR_FABRIC_HYPERSPECTRAL_HW_0_INTERRUPT_INTR XPAR_FABRIC_HYPERSPECTRAL_HW_W_0_INTERRUPT_INTR
#define XPAR_HYPERSPECTRAL_HW_0_S_AXI_CONTROL_BUS_BASEADDR XPAR_XSHYPERSPECTRAL_HW_WRAPPED_0_S_AXI_CONTROL_BUS_BASEADDR

volatile static int ResultExample = 0;

XHyperspectral_hw_wrapped xhyperspectral_dev;

XHyperspectral_hw_wrapped_Config xhyperspectral_config = {
		0,
		XPAR_HYPERSPECTRAL_HW_0_S_AXI_CONTROL_BUS_BASEADDR
};

// Interrupt Controller Instance
XSGuic ScuGic;

int XHyperspectralSetup() {
	return XHyperspectral_hw_wrapped_CfgInitialize(&xhyperspectral_dev,&xhyperspectral_config);
}

void XHyperspectralStart(void *InstancePtr) {
	XHyperspectral_hw_wrapped *pExample = (XHyperspectral_hw_wrapped *)InstancePtr;
	XHyperspectral_hw_wrapped_InterruptEnable (pExample,1);
	XHyperspectral_hw_wrapped_InterruptGlobalEnable(pExample);
	XHyperspectral_hw_wrapped_Start(pExample);
}

void XCalmaxIsr (void *InstancePtr) {
	XHyperspectral_hw_wrapped *pExample = (XHyperspectral_hw_wrapped *)InstancePtr;
	// DIsable the global interrupt
	XHyperspectral_hw_wrapped_InterruptGlobalDisable (pExample);
	// Disable the local interrupt
	XHyperspectral_hw_wrapped_InterruptDisable(pExample,0xffffffff);
	//clear the local interrupt
	XHyperspectral_hw_wrapped_InterruptClear(pExample,1);
	ResultExample = 1;
	XHyperspectral_hw_wrapped_InterruptEnable(pExample,1);
	XHyperspectral_hw_wrapped_InterruptGlobalEnable(pExample);


}

int XHyperspectralSetupInterrupt() {

	int result;
	XScuGic_Config *pCfg = XScuGic_LookupConfig(XPAR_SCUGIC_SINGLE_DEVICE_ID);
	if (pCfg == NULL){
		print("Interrupt Configuration Lookup Failed\n\r");
		return XST_FAILURE;
	}
	result = XScuGic_CfgInitialize(&ScuGic,pCfg,pCfg->CpuBaseAddress);
	if(result != XST_SUCCESS){
		return result;
	}
	// self test
	result = XScuGic_SelfTest(&ScuGic);
	if(result != XST_SUCCESS){
		return result;
	}
	// Initialize the exception handler
	Xil_ExceptionInit();
	// Register the exception handler
	//print("Register the exception handler\n\r");
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,(Xil_ExceptionHandler)XScuGic_InterruptHandler,&ScuGic);
	//Enable the exception handler
	Xil_ExceptionEnable();
	// Connect the Adder ISR to the exception table
	//print("Connect the Adder ISR to the Exception handler table\n\r");
	result = XScuGic_Connect(&ScuGic,XPAR_FABRIC_HYPERSPECTRAL_HW_0_INTERRUPT_INTR,(Xil_InterruptHandler)XHyperspectralStart,&xhyperspectral_dev);
	if(result != XST_SUCCESS){
		return result;
	}
	//print("Enable the Adder ISR\n\r");
	XScuGic_Enable(&ScuGic,XPAR_FABRIC_HYPERSPECTRAL_HW_0_INTERRUPT_INTR);
	return XST_SUCCESS;
}

int Setup_HW_Accelerator (uint16_t image[FILAS][COLUMNAS][BANDAS], int refPixel[2],
        int maxBrightness[2], float *minDistance, int closestPixel[2],
        unsigned int dma_sizeImage, unsigned int dma_sizeRefPixel,
        unsigned int dma_sizeMaxBrightness, unsigned int dma_sizeMinDistance,
        unsigned int dma_sizeClosestPixel) {
	int status = XHyperspectralSetup();
	if(status != XST_SUCCESS){
		print("Error: example setup failed\n");
		return XST_FAILURE;
	}
	status = XHyperspectralSetupInterrupt();
	if(status != XST_SUCCESS){
		print("Error: interrupt setup failed\n");
		return XST_FAILURE;
	}

	XHyperspectralStart(&xhyperspectral_dev);

	return 0;
}

int Start_HW_Accelerator(void) {
	int status = XHyperspectralSetup();
	if(status != XST_SUCCESS){
		print("Error: example setup failed\n");
		return XST_FAILURE;
	}
	status =  XHyperspectralSetupInterrupt();
	if(status != XST_SUCCESS){
		print("Error: interrupt setup failed\n");
		return XST_FAILURE;
	}

	XHyperspectralStart(&xhyperspectral_dev);

	return 0;
}

int Run_HW_Accelerator(uint16_t image[FILAS][COLUMNAS][BANDAS], int refPixel[2], int maxBrightness[2],
                       float *minDistance, int closestPixel[2],
                       unsigned int dma_sizeImage, unsigned int dma_sizeRefPixel,
                       unsigned int dma_sizeMaxBrightness, unsigned int dma_sizeMinDistance,
                       unsigned int dma_sizeClosestPixel) {

	// Transfer image to the hardware accelerator
	int status = XAxiDma_SimpleTransfer(&AxiDma, (unsigned int)image, dma_sizeImage, XAXIDMA_DMA_TO_DEVICE);
	if (status != XST_SUCCESS) {
		xil_printf("Error: DMA transfer of image to device failed\n");
		return XST_FAILURE;
	}

    // Transfer refPixel to the hardware accelerator
	status = XAxiDma_SimpleTransfer(&AxiDma, (unsigned int)refPixel, dma_sizeRefPixel, XAXIDMA_DMA_TO_DEVICE);
	if (status != XST_SUCCESS) {
		xil_printf("Error: DMA transfer of refPixel to device failed\n");
		return XST_FAILURE;
	}

	Start_HW_Accelerator();

	while (XAxiDma_Busy(&AxiDma, XAXIDMA_DMA_TO_DEVICE)) {}

	// Transfer maxBrightness from the hardware accelerator
	status = XAxiDma_SimpleTransfer(&AxiDma, (unsigned int)maxBrightness, dma_sizeMaxBrightness, XAXIDMA_DEVICE_TO_DMA);
	if (status != XST_SUCCESS) {
		xil_printf("Error: DMA transfer of maxBrightness from device failed\n");
		return XST_FAILURE;
	}

	// Transfer minDistance from the hardware accelerator
	status = XAxiDma_SimpleTransfer(&AxiDma, (unsigned int)minDistance, dma_sizeMinDistance, XAXIDMA_DEVICE_TO_DMA);
	if (status != XST_SUCCESS) {
		xil_printf("Error: DMA transfer of minDistance from device failed\n");
		return XST_FAILURE;
	}

	// Transfer closestPixel from the hardware accelerator
	status = XAxiDma_SimpleTransfer(&AxiDma, (unsigned int)closestPixel, dma_sizeClosestPixel, XAXIDMA_DEVICE_TO_DMA);
	if (status != XST_SUCCESS) {
		xil_printf("Error: DMA transfer of closestPixel from device failed\n");
		return XST_FAILURE;
	}

	// Wait for all transfers to complete
	while (XAxiDma_Busy(&AxiDma, XAXIDMA_DEVICE_TO_DMA)) {}

	// Invalidate the data cache to ensure data coherence after transfer
	Xil_DCacheInvalidateRange((unsigned int)maxBrightness, dma_sizeMaxBrightness);
	Xil_DCacheInvalidateRange((unsigned int)minDistance, dma_sizeMinDistance);
	Xil_DCacheInvalidateRange((unsigned int)closestPixel, dma_sizeClosestPixel);

	return XST_SUCCESS;

}
